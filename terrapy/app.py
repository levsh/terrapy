import argparse
import importlib
import logging
import os
import subprocess
import sys
import textwrap

from . import __version__


logging.basicConfig(format="[%(levelname)1.1s] %(message)s", level=logging.INFO)


CURDIR = os.path.abspath(os.path.curdir)
HEADER = "# This is an autogenerated file. Do not edit this file directly."


def format_dict(dct: dict, indent: int = 0) -> str:
    lines = []
    lines.append("{")
    for k, v in dct.items():
        if isinstance(v, dict):
            v = format_dict(v, indent=indent)
        elif isinstance(v, list):
            v = format_list(v, indent=indent)
        lines.append(textwrap.indent(f"{k} = {v}", "  "))
    lines.append("}")
    return textwrap.indent("\n".join(lines), "  " * indent)


def format_list(lst: list, indent: int = 0) -> str:
    lines = []
    lines.append("[")
    for item in lst:
        if isinstance(item, dict):
            item = format_dict(item, indent=indent)
        elif isinstance(item, list):
            item = format_list(item, indent=indent)
        lines.append(textwrap.indent(f"{item}", "  "))
    lines.append("]")
    return textwrap.indent("\n".join(lines), "  " * indent)


class Item:
    def __init__(self, item_type: str, *args, **kwds):
        self.type = item_type
        self.args = tuple(arg for arg in args if not isinstance(arg, Item))
        self.kwds = kwds
        self.items = tuple(item for item in args if isinstance(item, Item))

    def format(self) -> str:
        lines = []
        lines.append(self.type + "".join(' "{}"'.format(arg) for arg in self.args) + " {")
        for item in self.items:
            lines.append(textwrap.indent(item.format(), "  "))
        for k, v in self.kwds.items():
            if isinstance(v, dict):
                v = format_dict(v, indent=1)
            elif isinstance(v, list):
                v = format_list(v, indent=1)
            lines.append(f"  {k} = {v}")
        lines.append("}")
        return "\n".join(lines)


class Plan:
    def __init__(self):
        self.items = []

    @property
    def modules(self):
        return [item for item in self.items if item.type == "module"]

    def __iadd__(self, item: Item):
        if not isinstance(item, Item):
            raise ValueError
        self.items.append(item)
        return self

    # fmt: off
    def format(self):
        return "\n\n".join(
            map(
                lambda item: item.format(),
                filter(lambda item: item.type not in ("variable", "output"), self.items),
            )
        ).strip("\n")

    def format_vars(self):
        return "\n\n".join(
            map(
                lambda item: item.format(),
                filter(lambda item: item.type == "variable", self.items))
        ).strip("\n")

    def format_outs(self):
        return "\n\n".join(
            map(
                lambda item: item.format(),
                filter(lambda item: item.type == "output", self.items))
        ).strip("\n")
    # fmt: on


def clear_dir(odir: str):
    ans = input(
        (
            "All autogenerated '*.tf' and '*.tfvars' files and empty folders\n"
            f"inside {odir} directory will be deleted.\n"
            "Continue [y/n]: "
        )
    )
    print("")
    if ans != "y":
        logging.info("Aborted by user")
        sys.exit(-1)

    def clear(odir):
        for filename in filter(lambda item: item.endswith(".tf") or item.endswith(".tfvar"), os.listdir(odir)):
            with open(filename, "r") as f:
                if f.readline() != HEADER:
                    continue
            os.remove(filename)

        for dirname in [item for item in os.listdir(odir) if os.path.isdir(item)]:
            if not os.listdir(dirname):
                os.rmdir(dirname)
            else:
                clear(dirname)
                if not os.listdir(dirname):
                    os.rmdir(dirname)

    clear(odir)


def load_main_module(moddir: str):
    curdir = os.path.abspath(os.path.curdir)

    try:
        os.chdir(moddir)
        if moddir not in set(sys.path):
            sys.path.append(moddir)

        modpath = os.path.join(moddir, "main.py")
        spec = importlib.util.spec_from_file_location("main", modpath)
        module = importlib.util.module_from_spec(spec)

        try:
            spec.loader.exec_module(module)
        except FileNotFoundError:
            logging.error(f"Module main.py not found in directory {moddir}")
            sys.exit(-1)

        if not hasattr(module, "plan") or not isinstance(module.plan, Plan):
            logging.error(f"Valid plan object not found in module {modpath}")
            sys.exit(-1)

        return module

    finally:
        os.chdir(curdir)


def write(odir: str, module: object):
    def write_file(content, file_name):
        file_path = os.path.join(odir, file_name)
        with open(file_path, "w") as f:
            f.write("\n\n".join((HEADER, content)))

    os.makedirs(odir, exist_ok=True)

    body = module.plan.format()
    if body:
        write_file(body, "main.tf")

    variables = module.plan.format_vars()
    if variables:
        write_file(variables, "variables.tf")

    outputs = module.plan.format_outs()
    if outputs:
        write_file(outputs, "outputs.tf")

    for item in module.plan.modules:
        source = item.kwds.get("source", "").strip('"')
        if source and (source.startswith(".") or source.startswith("..")):
            module = load_main_module(os.path.abspath(source))
            moddir = os.path.join(odir, source)
            curdir = os.path.abspath(os.path.curdir)
            try:
                os.chdir(os.path.join(curdir, source))
                write(moddir, module)
            finally:
                os.chdir(curdir)


def generate(idir: str, odir: str):
    if os.path.exists(odir):
        clear_dir(odir)

    os.chdir(idir)

    module = load_main_module(idir)
    write(odir, module)

    try:
        subprocess.run(["terraform", "fmt"], cwd=odir, check=True)
    except subprocess.CalledProcessError as e:
        logging.error(e)
        sys.exit(-1)


def upgrade(odir: str):
    items = os.listdir(odir)

    if any(filter(lambda item: item.endswith(".tf"), items)):
        try:
            subprocess.run(["terraform", "0.13upgrade", "-yes"], cwd=odir, check=True)
        except subprocess.CalledProcessError as e:
            logging.error(e)
            sys.exit(-1)

    for item in items:
        item = os.path.join(odir, item)
        if os.path.isdir(item):
            upgrade(item)


def generate_cmd(args):
    generate(args.idir, args.idir)
    if args.upgrade:
        upgrade(args.idir)


def main():
    parser = argparse.ArgumentParser(description="Python to Terraform converter utility")
    parser.add_argument("-V", "--version", action="version", version="%(prog)s {}".format(__version__))

    subparsers = parser.add_subparsers(title="subcommands")

    parser_generate_cmd = subparsers.add_parser(
        "generate", description="Generate terraform plans", help="generate terraform plans"
    )
    parser_generate_cmd.add_argument(
        "-u", "--upgrade", action="store_true", help="run 'terraform 0.13upgrade' command for each module"
    )
    parser_generate_cmd.add_argument(
        "idir",
        metavar="DIR",
        default=CURDIR,
        nargs="?",
        help="directory with root main.py (default: current directory)",
    )
    parser_generate_cmd.set_defaults(func=generate_cmd)

    args = parser.parse_args()
    args.func(args)


if __name__ == "__main__":
    main()
